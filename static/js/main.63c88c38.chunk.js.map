{"version":3,"sources":["App.js","utils.js","serviceWorker.js","index.js"],"names":["App","useState","byteArr","setByteArr","className","onClick","copyText","document","getElementById","select","setSelectionRange","execCommand","alert","id","name","value","placeholder","onChange","event","target","data","trim","replace","response","byteCharacters","atob","byteArrays","offset","length","slice","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","push","blob","Blob","type","b64toBlob","blobUrl","URL","createObjectURL","window","open","openNewTab","arrayBuffer","chunk","base64","encodings","bytes","byteLength","byteRemainder","mainLength","base64ArrayBuffer","JSON","parse","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"4QA2GeA,MArGf,WAAgB,IAAD,EACmBC,mBAAS,IAD5B,mBACLC,EADK,KACIC,EADJ,KAmEb,OACE,yBAAKC,UAAU,OACb,2DACA,kWAMA,yBAAKA,UAAU,OACb,yBAAKA,UAAU,gBACb,2CACA,yBAAKA,UAAU,cACb,uBAAGC,QA5BM,WAEjB,IAAIC,EAAWC,SAASC,eAAe,iBAGvCF,EAASG,SACTH,EAASI,kBAAkB,EAAG,OAG9BH,SAASI,YAAY,QAGrBC,MAAM,eAgBE,QACA,uBAAGP,QAjCO,WAClBF,EAAW,MAgCH,WAGJ,8BACEU,GAAG,gBACHT,UAAU,YACVU,KAAK,OACLC,MAAOb,EACPc,YAAY,mDACZC,SA5Da,SAAAC,GAAU,IACrBH,EAAUG,EAAMC,OAAhBJ,MACRZ,EAAWY,OA6DT,6BACA,4BAAQV,QA3DU,WACpB,GAAgB,KAAZH,EACFU,MAAM,iCAEH,CACH,IAAIQ,EAAOlB,EAAQmB,OAAOC,QAAQ,KAAK,IACvCF,EAAKE,QAAQ,YAAa,IAtCX,SAACC,GAOlB,IANA,IAGIC,EAAiBC,KAAKF,GACtBG,EAAa,GAERC,EAAS,EAAGA,EAASH,EAAeI,OAAQD,GALrC,IAK0D,CAIxE,IAHA,IAAIE,EAAQL,EAAeK,MAAMF,EAAQA,EAN3B,KAQVG,EAAc,IAAIC,MAAMF,EAAMD,QACzBI,EAAI,EAAGA,EAAIH,EAAMD,OAAQI,IAChCF,EAAYE,GAAKH,EAAMI,WAAWD,GAGpC,IAAIE,EAAY,IAAIC,WAAWL,GAE/BJ,EAAWU,KAAKF,GAGlB,IAAIG,EAAO,IAAIC,KAAKZ,EAAY,CAACa,KAnBf,oBAoBlBF,EAAOG,IAAUjB,EApBC,mBAqBlB,IAAIkB,EAAUC,IAAIC,gBAAgBN,GAElCO,OAAOC,KAAKJ,GAiBVK,CClD2B,SAACC,GAa9B,IAZA,IASIC,EATAC,EAAY,GACZC,EAAY,mEAEZC,EAAgB,IAAIhB,WAAWY,GAC/BK,EAAgBD,EAAMC,WACtBC,EAAgBD,EAAa,EAC7BE,EAAgBF,EAAaC,EAMxBrB,EAAI,EAAGA,EAAIsB,EAAYtB,GAAQ,EAWtCiB,GAAUC,GANG,UAHbF,EAASG,EAAMnB,IAAM,GAAOmB,EAAMnB,EAAI,IAAM,EAAKmB,EAAMnB,EAAI,MAGjC,IAMDkB,GALZ,OAARF,IAAqB,IAKcE,GAJ3B,KAARF,IAAsB,GAI4BE,EAH3C,GAARF,GA4BN,OArBsB,IAAlBK,EAQFJ,GAAUC,GALG,KAFbF,EAAQG,EAAMG,MAEO,GAKIJ,GAFZ,EAARF,IAAgB,GAEmB,KACb,IAAlBK,IASTJ,GAAUC,GANG,OAFbF,EAASG,EAAMG,IAAe,EAAKH,EAAMG,EAAa,MAE/B,IAMEJ,GALZ,KAARF,IAAmB,GAKgBE,GAF3B,GAARF,IAAmB,GAE+B,KAGlDC,EDAUM,CADDC,KAAKC,MAAM,IAAIrC,EAAK,UAoDlC,+BExFcsC,QACW,cAA7Bd,OAAOe,SAASC,UAEe,UAA7BhB,OAAOe,SAASC,UAEhBhB,OAAOe,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFzD,SAASC,eAAe,SDyHpB,kBAAmByD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.63c88c38.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport b64toBlob from 'b64-to-blob';\r\nimport './App.css';\r\n\r\nimport { base64ArrayBuffer } from './utils';\r\n\r\nfunction App() {\r\n  const [ byteArr, setByteArr ] = useState(\"\");\r\n\r\n  const openNewTab = (response) => {\r\n    var contentType = 'application/pdf';\r\n    var sliceSize = 512;\r\n\r\n    var byteCharacters = atob(response);\r\n    var byteArrays = [];\r\n\r\n    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {\r\n      var slice = byteCharacters.slice(offset, offset + sliceSize);\r\n\r\n      var byteNumbers = new Array(slice.length);\r\n      for (var i = 0; i < slice.length; i++) {\r\n        byteNumbers[i] = slice.charCodeAt(i);\r\n      }\r\n\r\n      var byteArray = new Uint8Array(byteNumbers);\r\n\r\n      byteArrays.push(byteArray);\r\n    }\r\n\r\n    var blob = new Blob(byteArrays, {type: contentType});\r\n    blob = b64toBlob(response, contentType);\r\n    var blobUrl = URL.createObjectURL(blob);\r\n\r\n    window.open(blobUrl);\r\n  }\r\n\r\n  const handleChange = event => {\r\n    const { value } = event.target;\r\n    setByteArr(value);\r\n  }\r\n\r\n  const handleConvert = () => {\r\n    if (byteArr === \"\") {\r\n      alert(\"Input must not be empty !\");\r\n    }\r\n    else {\r\n      let data = byteArr.trim().replace(/ /g,'');\r\n      data.replace(/\\r?\\n|\\r/g, '');\r\n      let arrData = JSON.parse(\"[\"+data+\"]\");\r\n      const base64 = base64ArrayBuffer(arrData);\r\n      openNewTab(base64);\r\n    }\r\n  }\r\n\r\n  const handleClear = () => {\r\n    setByteArr(\"\");\r\n  }\r\n\r\n  const handleCopy = () => {\r\n      /* Get the text field */\r\n    var copyText = document.getElementById(\"byte-arr-area\");\r\n\r\n    /* Select the text field */\r\n    copyText.select();\r\n    copyText.setSelectionRange(0, 99999); /*For mobile devices*/\r\n\r\n    /* Copy the text inside the text field */\r\n    document.execCommand(\"copy\");\r\n\r\n    /* Alert the copied text */\r\n    alert(\"Copied ! \");\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>Byte Array to PDF Converter</h1>\r\n      <p>\r\n        Convert Byte Array to PDF online using a free decoding tool which allows you to \r\n        decode Byte Array as PDF and display it directly in the browser.\r\n        In addition, you will receive some basic information about this PDF (MIME type, extension, size).\r\n        And, of course, you will have a special link to download the PDF to your device. \r\n      </p>\r\n      <div className=\"box\">\r\n        <div className=\"flex-between\"> \r\n          <h3>Byte Array*</h3>\r\n          <div className=\"flex-start\">\r\n            <p onClick={handleCopy}>Copy</p>\r\n            <p onClick={handleClear}>Clear</p>\r\n          </div>\r\n        </div>\r\n        <textarea  \r\n          id=\"byte-arr-area\"\r\n          className=\"text-area\" \r\n          name=\"data\" \r\n          value={byteArr}\r\n          placeholder=\"Example : 37, 80, 68, 70, 45, 49, 46, 52, 10, 37\"\r\n          onChange={handleChange}\r\n        />\r\n      </div>\r\n      <br/>\r\n      <button onClick={handleConvert}>\r\n        Convert Byte Array to PDF\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","export const base64ArrayBuffer = (arrayBuffer) => {\r\n    var base64    = ''\r\n    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  \r\n    var bytes         = new Uint8Array(arrayBuffer)\r\n    var byteLength    = bytes.byteLength\r\n    var byteRemainder = byteLength % 3\r\n    var mainLength    = byteLength - byteRemainder\r\n  \r\n    var a, b, c, d\r\n    var chunk\r\n  \r\n    // Main loop deals with bytes in chunks of 3\r\n    for (var i = 0; i < mainLength; i = i + 3) {\r\n      // Combine the three bytes into a single integer\r\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]\r\n  \r\n      // Use bitmasks to extract 6-bit segments from the triplet\r\n      a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18\r\n      b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12\r\n      c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6\r\n      d = chunk & 63               // 63       = 2^6 - 1\r\n  \r\n      // Convert the raw binary segments to the appropriate ASCII encoding\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]\r\n    }\r\n  \r\n    // Deal with the remaining bytes and padding\r\n    if (byteRemainder === 1) {\r\n      chunk = bytes[mainLength]\r\n  \r\n      a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2\r\n  \r\n      // Set the 4 least significant bits to zero\r\n      b = (chunk & 3)   << 4 // 3   = 2^2 - 1\r\n  \r\n      base64 += encodings[a] + encodings[b] + '=='\r\n    } else if (byteRemainder === 2) {\r\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]\r\n  \r\n      a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10\r\n      b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4\r\n  \r\n      // Set the 2 least significant bits to zero\r\n      c = (chunk & 15)    <<  2 // 15    = 2^4 - 1\r\n  \r\n      base64 += encodings[a] + encodings[b] + encodings[c] + '='\r\n    }\r\n    \r\n    return base64\r\n}","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}